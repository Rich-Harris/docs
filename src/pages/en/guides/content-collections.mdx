---
layout: ~/layouts/MainLayout.astro
title: Content Collections
description: >-
  Content collections help organize your Markdown and type-check your
  frontmatter with schemas.
i18nReady: false
---
import FileTree from '~/components/FileTree.astro'
import Since from '~/components/Since.astro'
import TypeScriptSettingTabs from '~/components/tabs/TypeScriptSettingTabs.astro'



<p>
  <Since v="2.0.0" />
</p>

**Content collections** are a feature to help manage your Markdown and MDX files in Astro. A collection will organize your content, validate your frontmatter, and provide automatic TypeScript type-safety of fetched content. 

Content collections are the best way to work with Markdown and MDX in your project. For smaller projects, you can also [save your Markdown directly inside of the `src/pages/` directory.](/en/core-concepts/astro-pages/#markdownmdx-pages)

## What are Content Collections?

A *content collection() is any directory inside the reserved `src/content` project directory, such as `src/content/newsletter` and `src/content/blog`. Only content collections are allowed inside the `src/content` directory. This directory cannot be used for anything else.

Content collections help you organize the content files in your project. A content collection can contain any number of related Markdown (`.md`) or MDX (`.mdx`) files. These files within a collection are called **content entries.**

<FileTree>
- src/content/
  - **newsletter/** 
    - week-1.md
    - week-2.md
    - week-3.md
</FileTree>

Once you have a content collection in place with at least one content entry, you can query your content using Astro's built-in APIs.

### Creating a new content collection

To create a new content collection, add a new top-level directory to the `src/content/` folder of your project. If a `src/content` directory doesn't already exist in your project, create it.

Fill your collection directory with related Markdown and/or MDX files. Content collections work best when all files in the collection follow a similar frontmatter structure. If two files represent two different kinds of content (a blog post and an author profile, for example) they most likely belong in two different collections. 

<FileTree>
- src/content/
  - **newsletter/** 
    - week-1.md
    - week-2.md
    - week-3.md
  - **authors/** diffrent content types belong in different collections
    - grace-hopper.md
    - alan-turing.md
    - batman.md
</FileTree>

If your content frontmatter varries too wildly between files in a single collection, features like frontmatter validation and automatic TypeScript typings become less powerful. You can optionally define and enforce a required [frontmatter schema](/en/guides/content-collections/#defining-a-collection-schema) across the entire collection.

### Organizing your collections with subdirectories

A content collection is *always* a top-level folder inside of the `src/content/` directory. You cannot nest one collection inside of another. However, you can use a nested subdirectory to organize your content within a collection. 

For example, you can use the following subdirectory structure to add international translations within a collection:

<FileTree>
- src/content/
  - docs/
    - en/
    - es/
    - ...
</FileTree>

## Configuration

Astro allows you to customize and configure your project's content collections through an optional `src/content/config.ts` file (`.js` and `.mjs` extensions are also supported). 

Currently, this file supports [defining a collection schema](#defining-a-collection-schema) and [creating custom unique slugs](#custom-entry-slugs) for your collections.

### Creating a collection schema

Schemas are an optional way to enforce consistent frontmatter within a collection. Without a schema, you have no way to guarantee that a frontmatter property actually exists when you go to reference it inside a page or component template.

To create a content collection schema, first create a `src/content/config.ts` file if one does not already erxist (`.js` and `.mjs` extensions are also supported). This file should:

1. Import the proper utilities from `astro:content`. 
2. Define a schema for each collection you'd like to validate.
3. Export a single `collections` object to apply your schemas.

```ts
// src/content/config.ts
// 1. Import the proper utilities from `astro:content`
import { z, defineCollection } from 'astro:content';

// 2. Define a schema for each collection you'd like to validate.
const blogSchema = defineCollection({
  schema: z.object({
    title: z.string(),
    tags: z.array(z.string()),
    image: z.string().optional(),
  }),
});

// 3. Export a single `collections` object to apply your schemas.
export const collections = {
  'blog': blogSchema,
};
```


### Defining datatypes with Zod

Astro leverages [Zod](https://github.com/colinhacks/zod) to create frontmatter schemas in the form of [Zod objects](https://github.com/colinhacks/zod#objects). With Zod, Astro is able to validate every file's frontmatter within a collection *and* provide automatic TypeScript types when you go to query content from inside your project.

To use Zod in Astro, import the `z` utility from `"astro:content"`. This is a re-export of the Zod library, and you are able to use all Zod features inside of Astro. See [Zodâ€™s README](https://github.com/colinhacks/zod) for complete documentation on how Zod works and what features are available.


```ts
// Example: A cheatsheet of many common Zod datatypes
import { z, defineCollection } from 'astro:content';

defineCollection({
  schema: z.object({
    isDraft: z.boolean(),
    title: z.string(),
    sortOrder: z.number(),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    author: z.string().default('Anonymous'),
    language: z.enum(['en', 'es']),
    tags: z.array(z.string()),
    // An optional frontmatter property. Very common!
    footnote: z.string().optional(),
    // Convert a standard date-string into a `Date` object
    publishDate: z.string().transform(str => new Date(str)),
    // Advanced: Validate that the string is also an email
    authorContact: z.string().email(),
    // Advanced: Validate that the string is also a URL
    canonicalURL: z.string().url(),
  })
})
```

### Defining custom slugs

Astro will generate a unique `slug` value for each content entry. By default, a content entry's `slug` is based on its `id` (its filename).

To customize this value, provide a `slug()` function in `defineCollection()`. Your `slug()` function can override the default slug with a custom value of your choosing.

```ts {4-6}
// Example: Override the default entry slug with the 
// "permalink" frontmatter property, if it exists.
const blog = defineCollection({
  slug: ({ id, defaultSlug, data, body }) => {
    return data.permalink || defaultSlug;
  },
});
```


### Updating TypeScript configuration

To benefit from the full TypeScript and autocompletion features of [using schemas with your collections](#defining-a-collection-schema), you may need to update your `tsconfig.json` to enable `strictNullChecks`.

```json title="tsconfig.json" ins={3}
{
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

Note that if you are currently extending Astro's `strict` or `strictest` recommended settings, than no changes is needed!

```json title="tsconfig.json" "strict" "strictest"
{
  // No change needed!
  "extends": "astro/tsconfigs/strict"
}
```



### Set up the `.astro` directory

Astro generates TypeScript types from your content collections in the `.astro` directory. These types will be updated anytime you run the [`astro dev`](/en/reference/cli-reference/#astro-dev), [`astro build`](/en/reference/cli-reference/#astro-build), or [`astro sync`](/en/reference/cli-reference/#astro-sync) commands.

:::tip
If you're using Git for version control, we recommend ignoring this generated directory by adding `.astro` to your `.gitignore`.
:::

These commands will also generate a [reference path](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-path-) to include `.astro` types in your project. A [`src/env.d.ts` file](/en/guides/typescript/#setup) will be created for you if one does not exist, and the following will be added:

```ts title="src/env.d.ts"
// using a relative path `../` to the `.astro` directory
/// <reference types="../.astro/types.d.ts" />
```

## The content directory

Astro treats the `src/content/` directory as special. This is where **collections** (folders) of Markdown/MDX **entries** (files) can be stored, with a single configuration file to define each collection's **schema** (frontmatter data types and shape). Files other than your `.md`/`.mdx` content are not permitted inside `src/content/`.


## Querying Collections

Astro provides two functions to query the content inside of a collection:

### `getCollection()`

`getCollection()` returns an array of all entries in a collection. It requires the name of a `collection` as an argument.

```js
import { getCollection } from 'astro:content';
const allBlogPosts = await getCollection('blog');
```

`getCollection` also takes a "filter" callback as an optional second argument. This allows you to filter your query based on an entry's `id`, `slug`, or `data` (frontmatter) properties.

```js
// Example: Only return entries with `draft: true` frontmatter
import { getCollection } from 'astro:content';
const draftBlogPosts = await getCollection('blog', ({ data }) => {
  return data.draft === true;
});
```

#### Filtering nested directories

The filter argument lets you query for nested directories within a collection. Since the `id` includes the full nested path, you can filter by the start of each `id` to only return items from a specific nested directory:

```js
// Example: Only return entries from `src/content/docs/en/`
import { getCollection } from 'astro:content';
const enDocs = await getCollection('docs', ({ id }) => {
  return id.startsWith('en/');
});
```

### `getEntry()`

`getEntry()` is function that returns a specific entry in a collection. It takes two arguments: the collection name and the content entry's `id` (aka its file path, relative to the collection).

```js
import { getEntry } from 'astro:content';
const entry = await getEntry('blog', 'enterprise.md');
```

### Using content in templates

Once you have queried your content, you can use the returned entries inside of your Astro pages and components. For example, you can include frontmatter in a component template, or pass an entire content entry object as a prop.

In the following example, we bring together everything we've learned to display a filtered list of links to your blog:

```astro
---
// src/pages/index.astro
import { getCollection } from 'astro:content';

// Get all blog posts, filtered by `status: published`
const blogPosts = await getCollection('blog', ({ data }) => {
  return data.status === 'published';
});
---
<ul>
  {blogPosts.map(post => (
    <li>
      <a href={`/my-blog-post-url/${post.slug}`}>{post.data.title}</a>
      <time datetime={post.data.publishedDate.toISOString()}>
        {post.data.publishedDate.toDateString()}
      </time>
    </li>
  ))}
</ul>
```

### Advanced TypeScript support

If a component uses content from a `getCollection()` or `getEntry()` query, you can use the `CollectionEntry` utility to type its props with TypeScript.

```astro /CollectionEntry(?:<.+>)?/
---
// src/components/BlogCard.astro
import type { CollectionEntry } from 'astro:content';
interface Props {
  // `post` will now match your collection schema
  post: CollectionEntry<'blog'>;
}

const { post } = Astro.props;
---
```

## Rendering Content

Once queried, you can render an entry to HTML using the entry `render()` function property. Calling this function gives you access to rendered content and metadata, including both a `<Content />` component and a list of all rendered headings.

```astro {5}
---
// src/pages/render-example.astro
import { getEntry } from 'astro:content';
const entry = await getEntry('blog', 'post-1.md');
const { Content, headings } = await entry.render();
---
<p>Written by: {entry.data.author}</p>
<Content />
```


### Advanced: Modifying frontmatter with remark

:::caution
Remark and rehype plugins access the _raw_ Markdown or MDX document frontmatter. This means that `remarkPluginFrontmatter` frontmatter is handled seperately from your type-safe `schema`, and will not reflect any changes or defaults applied through Astro. Use at your own risk!
:::

While not recommended, Astro allows you to [modify frontmatter directly](/en/guides/markdown-content/#modifying-frontmatter-programmatically) using remark or rehype plugins. You can access this modified frontmatter within Content Collections by using the `remarkPluginFrontmatter` property returned from `render()`:

```astro "{ remarkPluginFrontmatter }"
---
import { getEntry } from 'astro:content';
const blogPost = await getEntry('blog', 'post-1');
const { remarkPluginFrontmatter } = await blogPost.render();
---
<!-- 
  This example assumes `readingTime` was injected by a remark plugin.
  See our "reading time" example for more details:
  https://docs.astro.build/en/guides/markdown-content/#example-calculate-reading-time
-->
<p>{blogPost.data.title} â€” {remarkPluginFrontmatter.readingTime}</p>
```

<details>
<summary>**ðŸ™‹ Why don't `getCollection()` and `getEntry()` contain these values?**</summary>

The remark and rehype pipelines are only run when your content is **rendered.** This lets `render()` access anything generated by these plugins like injected frontmatter. To stay performant, `getCollection()` and `getEntry()` do not have this capability.

</details>


## Generating Pages

Because content collections live outside of the `src/pages` directory, you can use [dynamic routes](/en/core-concepts/routing/#dynamic-routes) to create pages from your collection entries.

If you are building a static website (Astro's default), use `getCollection()` inside a [`getStaticPaths()`](/en/reference/api-reference/#getstaticpaths) function to query your content entries and provide the `slug` parameter for each page. 

```astro "{ slug: entry.slug }"
---
// src/pages/posts/[...slug].astro
import { getCollection } from 'astro:content';

export async function getStaticPaths() {
  const blog = await getCollection('blog');
  return blog.map(entry => ({
    params: { slug: entry.slug }, props: { entry },
  }));
}

const { entry } = Astro.props;
const { Content } = await entry.render();
---
<h1>{entry.data.title}</h1>
<Content />
```

This will generate page routes for every entry in the `blog` collection, mapping each entryâ€™s slug to a URL. For example, an entry at `src/content/blog/hello-world.md` will have a slug of `hello-world` and the collection entry `src/content/blog/en/intro.md` will have a slug of `en/intro`.

Because this dynamic route is in `src/pages/posts/`, the final URLs will be `/posts/hello-world/` and `/posts/en/intro/`.

#### Generating pages in SSR mode

If you are deploying your site as a dynamic server (SSR mode), use `getEntry()` to query an entry directly based on the requested pathname.

```astro "{ slug: entry.slug }"
---
// TODO
---
```
